package foo:bar;

interface foo {
  resource bar {
    constructor();
    a: static func();
    b: func();
  }

  a: func(x: bar) -> bar;
  type t = bar;
  type t2 = own<bar>;
}

interface baz {
  use foo.{bar,t};
  a: func(x: bar) -> bar;

  b: func() -> t;
}


world some-world {
  use baz.{bar};

  resource a {
    constructor();
  }

  export x: func() -> a;
  export y: func() -> bar;

  import anon: interface {
    resource a {
      constructor();

      b: static func();

      c: func();
    }
  }
}

interface implicit-own-handles {
  resource a;

  b: func(a1: a, a2: a) -> own<a>;
  c: func() -> list<own<a>>;
}

interface implicit-own-handles2 {
  /// the `own` return and list param should be the same `own`
  resource a {
    constructor(a: list<a>);
  }

  /// same as above, even when the `list<b>` implicitly-defined `own` comes
  /// before an explicitly defined `own`
  resource b {
    constructor(a: list<b>, b: own<b>);
  }

  /// same as the above, the `own` argument should have the same type as the
  /// return value
  resource c {
    a: static func(a: own<c>) -> c;
  }
}

world implicit-own-handles3 {
  /// there should only be one `list` type despite there looking like two
  /// list types here
  resource a {
    constructor(a: list<a>, b: list<own<a>>);
  }
}
