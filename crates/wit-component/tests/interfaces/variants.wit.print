interface variants {
  union u1 {
    u32,
    float32,
  }

  enum my-errno {
    bad1,
    bad2,
  }

  record empty {
  }

  enum e1 {
    a,
  }

  variant v1 {
    a,
    b(u1),
    c(e1),
    d(string),
    e(empty),
    f,
    g(u32),
  }

  variant casts6 {
    a(tuple<float32, u32>),
    b(tuple<u32, u32>),
  }

  variant casts5 {
    a(float32),
    b(s64),
  }

  variant casts4 {
    a(u32),
    b(s64),
  }

  variant casts3 {
    a(float64),
    b(u64),
  }

  variant casts2 {
    a(float64),
    b(float32),
  }

  variant casts1 {
    a(s32),
    b(float32),
  }

  e1-arg: func(x: e1)

  e1-result: func() -> e1

  u1-arg: func(x: u1)

  u1-result: func() -> u1

  v1-arg: func(x: v1)

  v1-result: func() -> v1

  bool-arg: func(x: bool)

  bool-result: func() -> bool

  option-arg: func(a: option<bool>, b: option<tuple<>>, c: option<u32>, d: option<e1>, e: option<float32>, f: option<u1>, g: option<option<bool>>)

  option-result: func() -> tuple<option<bool>, option<tuple<>>, option<u32>, option<e1>, option<float32>, option<u1>, option<option<bool>>>

  casts: func(a: casts1, b: casts2, c: casts3, d: casts4, e: casts5, f: casts6) -> tuple<casts1, casts2, casts3, casts4, casts5, casts6>

  expected-arg: func(a: result, b: result<_, e1>, c: result<e1>, d: result<tuple<>, tuple<>>, e: result<u32, v1>, f: result<string, list<u8>>)

  expected-result: func() -> tuple<result, result<_, e1>, result<e1>, result<tuple<>, tuple<>>, result<u32, v1>, result<string, list<u8>>>

  return-expected-sugar: func() -> result<s32, my-errno>

  return-expected-sugar2: func() -> result<_, my-errno>

  return-expected-sugar3: func() -> result<my-errno, my-errno>

  return-expected-sugar4: func() -> result<tuple<s32, u32>, my-errno>

  return-option-sugar: func() -> option<s32>

  return-option-sugar2: func() -> option<my-errno>

  expected-simple: func() -> result<u32, s32>
}

world variants-world {
  import variants: self.variants
}
