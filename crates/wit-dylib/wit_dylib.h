// Generic implementation of a WIT world with a static set of functions.
//
// This is the header file for the dynamic library generated by
// `wasm-tools component wit-dylib`. This header describes in-memory data
// structures that are generated as well as functions that the dynamic library
// is expected to export.
//
// At a high level a `wit_t` provides type information during component
// initialization and then `wit_dylib_call_export` is used as the entrypoint to
// invoke functions. Various other `wit_dylib_*` intrinsics will receive indices
// relative to the original `wit_t` value. Values are represented as a 64-bit
// value `uint64_t` which the embedder can use any representation it likes
// within. Arguments/results are modeled as `uint64_t` and the embedder
// implements how to convert between this and WIT.

#ifndef WIT_INTERPRETER_H
#define WIT_INTERPRETER_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

typedef uint32_t wit_type_t;

#define WIT_TYPE_KIND(ty) ((ty) & 0xff)
#define WIT_TYPE_INDEX(ty) ((ty) >> 8)

#define WIT_TYPE_U8 0
#define WIT_TYPE_U16 1
#define WIT_TYPE_U32 2
#define WIT_TYPE_U64 3
#define WIT_TYPE_S8 4
#define WIT_TYPE_S16 5
#define WIT_TYPE_S32 6
#define WIT_TYPE_S64 7
#define WIT_TYPE_BOOL 8
#define WIT_TYPE_CHAR 9
#define WIT_TYPE_F32 10
#define WIT_TYPE_F64 11
#define WIT_TYPE_STRING 12
#define WIT_TYPE_ERROR_CONTEXT 13
#define WIT_TYPE_RECORD 14
#define WIT_TYPE_OWN 15
#define WIT_TYPE_BORROW 16
#define WIT_TYPE_FLAGS 17
#define WIT_TYPE_TUPLE 18
#define WIT_TYPE_VARIANT 19
#define WIT_TYPE_ENUM 20
#define WIT_TYPE_OPTION 21
#define WIT_TYPE_RESULT 22
#define WIT_TYPE_LIST 23
#define WIT_TYPE_FIXED_SIZE_LIST 24
#define WIT_TYPE_FUTURE 25
#define WIT_TYPE_STREAM 26
#define WIT_TYPE_ALIAS 27
#define WIT_TYPE_EMPTY 0xff

typedef void(*wit_fn)(uint64_t* values);

typedef struct wit_func {
     const char *interface;
     const char *name;
     wit_fn impl; // nullable
     size_t nparams;
     const wit_type_t *params;
     wit_type_t result;
} wit_func_t;

typedef void(*wit_resource_drop_t)(uint32_t);
typedef uint32_t(*wit_resource_new_t)(size_t);
typedef size_t(*wit_resource_rep_t)(uint32_t);

typedef struct wit_resource {
     const char *interface;
     const char *name;
     wit_resource_drop_t drop;
     wit_resource_new_t new; // nullable
     wit_resource_rep_t rep; // nullable
} wit_resource_t;

typedef struct wit_field {
     const char *name;
     wit_type_t ty;
} wit_field_t;

typedef struct wit_record {
     const char *interface;
     const char *name;
     size_t nfields;
     const wit_field_t *fields;
} wit_record_t;

typedef struct wit_flags {
     const char *interface;
     const char *name;
     size_t nnames;
     const char **names;
} wit_flags_t;

typedef struct wit_tuple {
     const char *interface;
     const char *name;
     size_t ntypes;
     const wit_type_t *types;
} wit_tuple_t;

typedef struct wit_case {
     const char *name;
     wit_type_t ty;
} wit_case_t;

typedef struct wit_variant {
     const char *interface;
     const char *name;
     size_t ncases;
     const wit_case_t *cases;
} wit_variant_t;

typedef struct wit_enum {
     const char *interface;
     const char *name;
     size_t nnames;
     const char **names;
} wit_enum_t;

typedef struct wit_option {
     const char *interface;
     const char *name;
     wit_type_t ty;
} wit_option_t;

typedef struct wit_result {
     const char *interface;
     const char *name;
     wit_type_t ok;
     wit_type_t err;
} wit_result_t;

typedef struct wit_list {
     const char *interface;
     const char *name;
     wit_type_t ty;
} wit_list_t;

typedef struct wit_fixed_size_list {
     const char *interface;
     const char *name;
     size_t size;
     wit_type_t ty;
} wit_fixed_size_list_t;

typedef struct wit_future {
     const char *interface;
     const char *name;
     wit_type_t ty;
} wit_future_t;

typedef struct wit_stream {
     const char *interface;
     const char *name;
     wit_type_t ty;
} wit_stream_t;

typedef struct wit_alias {
     const char *interface;
     const char *name;
     wit_type_t ty;
} wit_alias_t;

#define WIT_V0 0

typedef struct wit {
     uint32_t version; // `WIT_V*`

     size_t num_funcs;
     const wit_func_t *funcs;
     size_t num_resources;
     const wit_resource_t *resources;
     size_t num_records;
     const wit_record_t *records;
     size_t num_flags;
     const wit_flags_t *flags;
     size_t num_tuples;
     const wit_tuple_t *tuples;
     size_t num_variants;
     const wit_variant_t *variants;
     size_t num_enums;
     const wit_enum_t *enums;
     size_t num_options;
     const wit_option_t *options;
     size_t num_results;
     const wit_result_t *results;
     size_t num_lists;
     const wit_list_t *lists;
     size_t num_fixed_size_lists;
     const wit_fixed_size_list_t *fixed_size_lists;
     size_t num_futures;
     const wit_future_t *futures;
     size_t num_streams;
     const wit_stream_t *streams;
     size_t num_aliases;
     const wit_alias_t *aliases;
} wit_t;

// Invoked during `__wasm_call_ctors` with an in-memory `wit_t` data structure.
//
// The pointer provided lives for the lifetime of the entire program so it's
// safe to store this pointer.
void wit_dylib_initialize(const wit_t* wit);

// Entrypoint for WIT exports.
//
// `which` is an index into `wit->funcs` and `ptr` contains the lifted
// parameters of the functionc all. The result, if any, is stored at `ptr`.
void wit_dylib_call_export(size_t which, uint64_t *ptr);

// Entrypoint for WIT resource destructors.
//
// The `ty` poitns to `wit->resources` and `handle` is the value being
// destroyed.
void wit_dylib_resource_dtor(size_t ty, size_t handle);

// Generic byte deallocation function.
void wit_dylib_dealloc_bytes(void *ptr, size_t byte_size, size_t align);

// Deallocates an interpreter `val` provided, if necessary.
void wit_dylib_dealloc_val(uint64_t val);

// =============================================================================
// Functions used to lower values, or convert from interpreter `uint64_t`
// representations to WIT typed representations.
//
// Note that during lowering a `uint64_t` is NOT an "owned" value meaning that
// these functions should not allocate memory as it otherwise won't get cleaned
// up. For example the return value of `wit_dylib_list_get` is considered to be
// "borrowed" and not needing cleanup. This is suitable if, for example, the
// returned value is a pointer into the original list.

bool wit_dylib_lower_u8(uint64_t val);
uint16_t wit_dylib_lower_u16(uint64_t val);
uint32_t wit_dylib_lower_u32(uint64_t val);
uint64_t wit_dylib_lower_u64(uint64_t val);
int8_t wit_dylib_lower_s8(uint64_t val);
int16_t wit_dylib_lower_s16(uint64_t val);
int32_t wit_dylib_lower_s32(uint64_t val);
int64_t wit_dylib_lower_s64(uint64_t val);
float wit_dylib_lower_f32(uint64_t val);
double wit_dylib_lower_f64(uint64_t val);
bool wit_dylib_lower_bool(uint64_t val);
uint32_t wit_dylib_lower_char(uint64_t val);
uint32_t wit_dylib_lower_borrow(size_t ty, uint64_t val);
uint32_t wit_dylib_lower_own(size_t ty, uint64_t val);
uint32_t wit_dylib_lower_enum(size_t ty, uint64_t val);
uint32_t wit_dylib_lower_flags(size_t ty, uint64_t val);
uint32_t wit_dylib_lower_future(size_t ty, uint64_t val);
uint32_t wit_dylib_lower_stream(size_t ty, uint64_t val);
void wit_dylib_lower_record(size_t ty, uint64_t val, uint64_t *fields);
void wit_dylib_lower_tuple(size_t ty, uint64_t val, uint64_t *fields);
const uint8_t *wit_dylib_string_ptr(uint64_t val);
size_t wit_dylib_string_len(uint64_t val);
size_t wit_dylib_list_len(size_t type_index, uint64_t val);
const uint8_t *wit_dylib_list_ptr(size_t type_index, uint64_t val);
uint64_t wit_dylib_list_get(size_t type_index, size_t index, uint64_t val);
uint32_t wit_dylib_option_is_some(size_t type_index, uint64_t val);
uint64_t wit_dylib_option_payload(size_t type_index, uint64_t val);
uint32_t wit_dylib_result_is_err(size_t type_index, uint64_t val);
uint64_t wit_dylib_result_payload(size_t type_index, uint64_t val);
uint32_t wit_dylib_variant_discr(size_t type_index, uint64_t val);
uint64_t wit_dylib_variant_payload(size_t type_index, uint64_t val);

// =============================================================================
// Functions used to lift values, or convert from typed WIT representation to
// the interpreter's `uint64_t` representation.
//
// Unlike lowering these are considered to be "owned" operations. For example
// `wit_dylib_lift_option` is expected to take ownership of the `opt_payload`
// provided. The returned values will be either passed through to the program
// or cleaned up automatically in bindings.

uint64_t wit_dylib_lift_bool(uint32_t val);
uint64_t wit_dylib_lift_char(uint32_t val);
uint64_t wit_dylib_lift_u8(uint8_t val);
uint64_t wit_dylib_lift_s8(int8_t val);
uint64_t wit_dylib_lift_u16(uint16_t val);
uint64_t wit_dylib_lift_s16(int16_t val);
uint64_t wit_dylib_lift_u32(uint32_t val);
uint64_t wit_dylib_lift_s32(int32_t val);
uint64_t wit_dylib_lift_u64(uint64_t val);
uint64_t wit_dylib_lift_s64(int64_t val);
uint64_t wit_dylib_lift_f32(float val);
uint64_t wit_dylib_lift_f64(double val);
// Note that `bytes` and `len` are allocated by `cabi_realloc` and thus this
// function is required to take ownership of the values.
uint64_t wit_dylib_lift_string(uint8_t *bytes, size_t len);
// For record/tuple lifting the `vals` provided are a stack-local address.
//
// Each function is expected to read out the values and take ownership of the
// read values, but the pointer itself only lives for the duration of this
// function call.
uint64_t wit_dylib_lift_record(size_t ty, uint64_t *vals);
uint64_t wit_dylib_lift_tuple(size_t ty, uint64_t *vals);
uint64_t wit_dylib_lift_flags(size_t ty, uint32_t flags);
uint64_t wit_dylib_lift_enum(size_t ty, uint32_t enum_);
uint64_t wit_dylib_lift_borrow(size_t ty, uint32_t handle);
uint64_t wit_dylib_lift_own(size_t ty, uint32_t handle);
uint64_t wit_dylib_lift_future(size_t ty, uint32_t handle);
uint64_t wit_dylib_lift_stream(size_t ty, uint32_t handle);
uint64_t wit_dylib_lift_option(size_t ty, uint32_t discr, uint64_t opt_payload);
uint64_t wit_dylib_lift_result(size_t ty, uint32_t discr, uint64_t opt_payload);
uint64_t wit_dylib_lift_variant(size_t ty, uint32_t discr, uint64_t opt_payload);
// If this function returns 0 then it means that `bytes`/`len` need to be lifted
// one-by-one. If a nonzero value is returned then it's assume that `bytes` and
// `len` is now owned by the engine.
//
// Note that `bytes` was allocated with `cabi_realloc` and thus represents an
// owned allocation. This function takes ownership if a nonzero value is
// returned, otherwise the generated bindings will clean it up.
uint64_t wit_dylib_lift_list(size_t ty, uint8_t *bytes, size_t len);
uint64_t wit_dylib_list_alloc(size_t ty, size_t len);
uint64_t wit_dylib_list_push(size_t ty, uint64_t list, uint64_t val);

#endif
