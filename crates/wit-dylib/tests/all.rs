use anyhow::{Context, Result};
use libtest_mimic::{Arguments, Trial};
use std::path::{Path, PathBuf};
use std::process::Command;
use tempfile::TempDir;
use wit_component::Linker;
use wit_parser::{Resolve, WorldId};

fn main() {
    let mut trials = Vec::new();
    // All tests are stored in `artifacts::TESTS` which is generated by
    // `crates/wit-dylib/test-programs/artifacts/build.rs` and
    // contains all caller/callee paired components.
    for (caller, callee, wit) in artifacts::TESTS {
        let caller = Path::new(caller);
        let callee = Path::new(callee);
        let wit = Path::new(wit);
        let test_name = wit.file_name().unwrap().to_str().unwrap();
        let trial = Trial::test(test_name.to_string(), move || {
            let mut tempdir = TempDir::new_in(caller.parent().unwrap()).unwrap();
            run_test(&tempdir, caller, callee, wit)
                .with_context(|| {
                    tempdir.disable_cleanup(true);
                    format!(
                        "failed test {test_name:?}\nartifacts are in {:?}",
                        tempdir.path(),
                    )
                })
                .map_err(|e| format!("{e:?}").into())
        })
        .with_ignored_flag(cfg!(target_family = "wasm"));
        trials.push(trial);
    }

    libtest_mimic::run(&Arguments::from_args(), trials).exit();
}

fn run_test(tempdir: &TempDir, caller: &Path, callee: &Path, wit: &Path) -> Result<()> {
    let mut resolve = Resolve::default();
    let package = resolve.push_file(wit).context("failed to load WIT")?;

    // First load up the `caller` and link it all together into a component.
    let (_caller, caller_file) = create_component(
        tempdir,
        caller,
        &resolve,
        resolve.select_world(&[package], Some("caller"))?,
    )
    .context("failed to link caller together")?;

    // Next do the same for the `callee`
    let (_callee, callee_file) = create_component(
        tempdir,
        callee,
        &resolve,
        resolve.select_world(&[package], Some("callee"))?,
    )
    .context("failed to link callee together")?;

    // Use `wasm-compose` to create a single component where `caller` imports
    // the `callee`.
    let config = wasm_compose::config::Config {
        definitions: vec![callee_file],
        ..Default::default()
    };
    let composition = wasm_compose::composer::ComponentComposer::new(&caller_file, &config)
        .compose()
        .context("failed to compose")?;

    let composition_file = tempdir.path().join("composition.wasm");
    std::fs::write(&composition_file, &composition)
        .context("failed to write `composition.wasm`")?;

    // And finally run this component's `run` function in Wasmtime to ensure the
    // test passes.
    let mut cmd = Command::new("wasmtime");
    cmd.arg("run").arg("--invoke=run()").arg(&composition_file);
    let result = cmd.output().context("failed to run wasmtime")?;
    if result.status.success() {
        return Ok(());
    }

    let mut error = String::new();
    error.push_str(&format!("command: {cmd:?}\n"));
    error.push_str(&format!("status:  {}\n", result.status));
    if !result.stdout.is_empty() {
        error.push_str(&format!(
            "stdout:\n  {}",
            String::from_utf8_lossy(&result.stdout).replace("\n", "\n  ")
        ));
    }
    if !result.stderr.is_empty() {
        error.push_str(&format!(
            "stderr:\n  {}",
            String::from_utf8_lossy(&result.stderr).replace("\n", "\n  ")
        ));
    }

    anyhow::bail!("{error}")
}

fn create_component(
    tempdir: &TempDir,
    wasm: &Path,
    resolve: &Resolve,
    world: WorldId,
) -> Result<(Vec<u8>, PathBuf)> {
    let mut adapter = wit_dylib::create(resolve, world, None);
    let name = &resolve.worlds[world].name;

    wit_component::embed_component_metadata(
        &mut adapter,
        resolve,
        world,
        wit_component::StringEncoding::UTF8,
    )?;

    let adapter_file = tempdir.path().join(format!("{name}_adapter.wasm"));
    std::fs::write(&adapter_file, &adapter).context("failed to write `callee.wasm`")?;
    wasmparser::Validator::new_with_features(wasmparser::WasmFeatures::all())
        .validate_all(&adapter)
        .with_context(|| format!("adapter is invalid {adapter_file:?}"))?;

    let mut linker = Linker::default();

    // First define our caller/callee component with its own filename.
    linker = linker
        .library(
            wasm.file_name().unwrap().to_str().unwrap(),
            &std::fs::read(wasm).context("failed to read wasm")?,
            false,
        )
        .context("failed to link wasm as library")?;

    // Next insert the synthesized adapter that is what we're primarily testing
    // in this file.
    linker = linker
        .library(&format!("{name}-interpreter-adapter.wasm"), &adapter, false)
        .context("failed to link adapter as library")?;

    // Next load up `libc.so` as we specified in the compilation of the original
    // file that it should be linked dynamically.
    linker = linker
        .library(
            "libc.so",
            &std::fs::read(artifacts::LIBC_SO).context("failed to read libc.so")?,
            false,
        )
        .context("failed to link adapter as library")?;

    // Rust-sourced compiles still, as of the time of this writing, require the
    // WASIp1 adapter. Load that in here.
    linker = linker
        .adapter(
            "wasi_snapshot_preview1",
            wasi_preview1_component_adapter_provider::WASI_SNAPSHOT_PREVIEW1_REACTOR_ADAPTER,
        )
        .context("failed to load adapter")?;

    let wasm = linker.encode().with_context(|| {
        format!(
            "failed to link:\n\
original wasm: {wasm:?}\n\
adapter:       {adapter_file:?}\n\
libc:          {libc:?}\n\
",
            libc = artifacts::LIBC_SO,
        )
    })?;

    let wasm_file = tempdir.path().join(format!("{name}.wasm"));
    std::fs::write(&wasm_file, &wasm).with_context(|| format!("failed to write {wasm_file:?}"))?;
    Ok((wasm, wasm_file))
}
